[
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "8f70c8f2-eb26-4c0f-9a36-1d3e1c29757a",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC001-health check api returns server status and model info",
    "description": "Test the GET /health endpoint to verify it returns a 200 status with JSON containing the server status, provider, and model information when the backend is running.",
    "code": "import requests\n\nBASE_URL = \"http://localhost:8420\"\n\ndef test_health_check_api_returns_server_status_and_model_info():\n    url = f\"{BASE_URL}/health\"\n    try:\n        response = requests.get(url, timeout=30)\n        assert response.status_code == 200, f\"Expected 200 OK, got {response.status_code}\"\n        json_data = response.json()\n        assert \"status\" in json_data, \"Response JSON missing 'status'\"\n        assert json_data[\"status\"] == \"running\", f\"Expected status 'running', got {json_data['status']}\"\n        assert \"provider\" in json_data, \"Response JSON missing 'provider'\"\n        assert isinstance(json_data[\"provider\"], str) and json_data[\"provider\"], \"Provider should be a non-empty string\"\n        assert \"model\" in json_data, \"Response JSON missing 'model'\"\n        assert isinstance(json_data[\"model\"], str) and json_data[\"model\"], \"Model should be a non-empty string\"\n    except requests.exceptions.RequestException as e:\n        assert False, f\"Request to {url} failed with exception: {e}\"\n\ntest_health_check_api_returns_server_status_and_model_info()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 20, in <module>\n  File \"<string>\", line 12, in test_health_check_api_returns_server_status_and_model_info\nAssertionError: Expected status 'running', got ok\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.529Z",
    "modified": "2026-02-21T00:49:00.909Z"
  },
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "edfd90bc-b99e-4458-876f-a9d5e862657c",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC002-websocket generate streams tokens and completes successfully",
    "description": "Test the WebSocket /generate endpoint by sending a valid generation request with prompt, context, mode, and config, and verify that it streams token messages followed by a done message with the full response.",
    "code": "import json\nimport websocket\nimport threading\nimport time\nfrom testsprite_tests.proxy_connect import proxy_connect\n\nBASE_WS_URL = \"ws://localhost:8420/generate\"\n\n\ndef test_websocket_generate_streams_tokens_and_completes_successfully():\n    ws = None\n    received_tokens = []\n    done_message = None\n    error_occurred = False\n\n    def on_message(wsapp, message):\n        nonlocal done_message, error_occurred\n        msg = json.loads(message)\n        msg_type = msg.get(\"type\")\n        if msg_type == \"token\":\n            received_tokens.append(msg.get(\"content\"))\n        elif msg_type == \"done\":\n            done_message = msg.get(\"content\")\n            wsapp.close()\n        elif msg_type == \"error\":\n            error_occurred = True\n            wsapp.close()\n\n    def on_error(wsapp, error):\n        nonlocal error_occurred\n        error_occurred = True\n\n    def on_close(wsapp, close_status_code, close_msg):\n        pass\n\n    def on_open(wsapp):\n        # Send valid generation request\n        request_payload = {\n            \"prompt\": \"Hello, how are you?\",\n            \"context\": \"Previous conversation context.\",\n            \"mode\": \"generate\",\n            \"mode_type\": \"draft\",\n            \"config\": {\n                \"provider\": \"bedrock\",\n                \"model_id\": \"test-model\",\n                \"aws_profile\": \"default\",\n                \"aws_region\": \"us-west-2\"\n            }\n        }\n        wsapp.send(json.dumps(request_payload))\n\n    websocket.enableTrace(False)\n    ws = websocket.WebSocketApp(\n        BASE_WS_URL,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close,\n        on_open=on_open,\n        **proxy_connect()\n    )\n\n    wst = threading.Thread(target=ws.run_forever, kwargs={\"ping_interval\": 10, \"ping_timeout\": 5})\n    wst.daemon = True\n    wst.start()\n\n    timeout = 30\n    start_time = time.time()\n    while wst.is_alive() and (time.time() - start_time) < timeout:\n        if done_message or error_occurred:\n            break\n        time.sleep(0.1)\n\n    ws.close()\n\n    assert not error_occurred, \"Error message received from server\"\n    assert done_message is not None, \"Did not receive done message\"\n    assert received_tokens, \"Did not receive any token messages\"\n    combined_tokens = \"\".join(received_tokens)\n    # done message content should include the generated text containing the tokens collected\n    assert combined_tokens in done_message or done_message in combined_tokens, \"Done message content mismatch with tokens\"\n\n\ntest_websocket_generate_streams_tokens_and_completes_successfully()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 2, in <module>\nModuleNotFoundError: No module named 'websocket'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.535Z",
    "modified": "2026-02-21T00:48:55.723Z"
  },
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "29cfe995-63c2-4a16-906a-c3a52b0b7ac5",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC003-websocket generate handles malformed json with error message",
    "description": "Test the WebSocket /generate endpoint by sending malformed JSON or a message missing the required prompt field, and verify that the server responds with an error message indicating validation or parse error.",
    "code": "import websocket\nimport json\nimport time\nfrom testsprite_tests.proxy_helpers import proxy_connect\n\n\ndef test_websocket_generate_handles_malformed_json_with_error_message():\n    url = \"ws://localhost:8420/generate\"\n    ws = None\n    try:\n        ws = proxy_connect(url, timeout=30)\n\n        # 1. Send malformed JSON (invalid syntax)\n        ws.send('{\"prompt\": \"Hello world\",,,,}')  # malformed on purpose\n\n        # Expect to receive an error message indicating parse error\n        msg = ws.recv()\n        msg_data = json.loads(msg)\n        assert \"type\" in msg_data and msg_data[\"type\"] == \"error\"\n        assert (\n            \"error\" in msg_data.get(\"content\", \"\").lower()\n            or \"parse\" in msg_data.get(\"content\", \"\").lower()\n            or \"validation\" in msg_data.get(\"content\", \"\").lower()\n        )\n        \n        # 2. Send JSON missing required 'prompt' field\n        invalid_payload = {\n            \"context\": \"some context\",\n            \"mode\": \"generate\",\n            \"mode_type\": \"draft\",\n            \"config\": {\n                \"provider\": \"bedrock\",\n                \"model_id\": \"dummy-model\",\n                \"aws_profile\": \"dummy-profile\",\n                \"aws_region\": \"dummy-region\",\n            },\n        }\n        ws.send(json.dumps(invalid_payload))\n\n        # Expect to receive error message indicating validation error for missing prompt\n        msg2 = ws.recv()\n        msg_data2 = json.loads(msg2)\n        assert \"type\" in msg_data2 and msg_data2[\"type\"] == \"error\"\n        assert (\n            \"prompt\" in msg_data2.get(\"content\", \"\").lower()\n            or \"required\" in msg_data2.get(\"content\", \"\").lower()\n            or \"validation\" in msg_data2.get(\"content\", \"\").lower()\n        )\n\n    finally:\n        if ws:\n            ws.close()\n\n\ntest_websocket_generate_handles_malformed_json_with_error_message()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 1, in <module>\nModuleNotFoundError: No module named 'websocket'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.541Z",
    "modified": "2026-02-21T00:49:03.169Z"
  },
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "9d1798e3-8081-4157-8f36-01f76a649217",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC004-websocket generate supports cancellation of in progress generation",
    "description": "Test sending a cancel message during an active generation on the WebSocket /generate endpoint and verify that the server responds with a cancelled message and stops sending tokens.",
    "code": "import json\nimport time\nimport websocket\nfrom testsprite_tests import proxy_connect  # Assuming this helper is available for proxy and connection setup\n\nBASE_WS_URL = \"ws://localhost:8420/generate\"\n\ndef test_websocket_generate_supports_cancellation_of_in_progress_generation():\n    ws = None\n    try:\n        # Connect to the WebSocket using proxy_connect helper for tunnel and proxy support\n        ws = proxy_connect(BASE_WS_URL)\n\n        # Send a valid generation request to start streaming tokens\n        generation_request = {\n            \"prompt\": \"This is a test prompt to start generation.\",\n            \"context\": \"Testing cancellation during generation.\",\n            \"mode\": \"generate\",\n            \"mode_type\": \"draft\",\n            \"config\": {\n                \"provider\": \"bedrock\",\n                \"model_id\": \"test-model\",\n                \"aws_profile\": \"default\",\n                \"aws_region\": \"us-west-2\"\n            }\n        }\n        ws.send(json.dumps(generation_request))\n\n        received_token_messages = 0\n        cancelled_received = False\n\n        # Wait for some tokens, then send cancel message\n        timeout_at = time.time() + 30  # 30 seconds timeout\n        while time.time() < timeout_at:\n            raw_msg = ws.recv()\n            assert raw_msg is not None, \"Received None message from WebSocket\"\n            msg = json.loads(raw_msg)\n\n            # Accept types: token, done, error, cancelled\n            msg_type = msg.get(\"type\")\n            assert msg_type in (\"token\", \"done\", \"error\", \"cancelled\"), f\"Unexpected msg type {msg_type}\"\n\n            if msg_type == \"token\":\n                received_token_messages += 1\n                # After receiving at least 2 tokens, send cancellation\n                if received_token_messages == 2:\n                    ws.send(json.dumps({\"type\": \"cancel\"}))\n            elif msg_type == \"cancelled\":\n                cancelled_received = True\n                # After cancelled received, break loop as generation should stop\n                break\n            elif msg_type == \"done\":\n                # If generation finishes without cancel message received, assert fail\n                assert False, \"Generation completed before cancellation was confirmed\"\n            elif msg_type == \"error\":\n                # If error received, fail test\n                assert False, f\"Received error message from server: {msg.get('content')}\"\n        else:\n            # Timeout expired without receiving cancelled message\n            assert False, \"Timeout expired without receiving cancelled message\"\n\n        assert cancelled_received, \"Cancelled message was not received after sending cancel\"\n\n        # Ensure no further tokens are received after cancellation\n        # Wait shortly to see if unexpected tokens come after cancelled\n        time.sleep(1)\n        # Non-blocking check, if more messages received they would be tokens or otherwise\n        try:\n            ws.settimeout(1)\n            followup_msg = ws.recv()\n            followup = json.loads(followup_msg)\n            # After cancellation, no token or done messages should be received\n            assert followup.get(\"type\") != \"token\", \"Received token after cancellation\"\n            assert followup.get(\"type\") != \"done\", \"Received done after cancellation\"\n        except websocket.WebSocketTimeoutException:\n            # Expected no messages after cancelled\n            pass\n\n    finally:\n        if ws:\n            ws.close()\n\ntest_websocket_generate_supports_cancellation_of_in_progress_generation()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 3, in <module>\nModuleNotFoundError: No module named 'websocket'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.547Z",
    "modified": "2026-02-21T00:48:55.280Z"
  },
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "22fd64bc-87e5-449d-9254-c5f45abe666c",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC005-websocket generate cancel without active generation returns error or noop",
    "description": "Test sending a cancel message on the WebSocket /generate endpoint when no generation is active and verify that the server responds with an error or no-op message indicating no active generation to cancel.",
    "code": "import websocket\nimport json\nimport threading\nimport time\nfrom testsprite_tests import proxy_connect\n\nBASE_WS_URL = \"ws://localhost:8420/generate\"\n\ndef test_websocket_generate_cancel_without_active_generation_returns_error_or_noop():\n    ws = websocket.WebSocket()\n    try:\n        # Connect to the /generate WebSocket endpoint using proxy_connect for proxy support and handshake\n        proxy_connect(ws, BASE_WS_URL)\n\n        # Send a cancel message when no generation is active\n        cancel_msg = json.dumps({\"type\": \"cancel\"})\n        ws.send(cancel_msg)\n\n        # Wait and read response(s)\n        # The server should respond with an error or no-op message indicating no active generation to cancel\n        # We'll allow multiple messages and look for at least one indicating error or no active generation\n        received = False\n        timeout = time.time() + 10  # 10 second timeout for receiving message\n        while time.time() < timeout:\n            try:\n                msg = ws.recv()\n                if not msg:\n                    continue\n                data = json.loads(msg)\n                # Accept responses with type \"error\" or others indicating no active generation to cancel\n                if \"type\" not in data:\n                    continue\n                if data[\"type\"] == \"error\":\n                    # Assert error message mentions no active generation or cancel not possible\n                    assert any(s in data.get(\"content\", \"\").lower() for s in [\"no active generation\", \"nothing to cancel\", \"cannot cancel\"])\n                    received = True\n                    break\n                # Some servers may send a no-op or a specific message type for no active generation\n                # We accept any valid message type except cancelled or done here\n                elif data[\"type\"] in (\"cancelled\", \"done\", \"token\"):\n                    # These types not expected as no generation is active, fail if received\n                    assert False, f\"Unexpected message type received: {data['type']}\"\n                else:\n                    # No-op or other informative messages accepted to satisfy test\n                    received = True\n                    break\n            except websocket.WebSocketTimeoutException:\n                break\n\n        assert received, \"Did not receive an error or no-op message response after cancel with no active generation\"\n\n    finally:\n        ws.close()\n\ntest_websocket_generate_cancel_without_active_generation_returns_error_or_noop()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 1, in <module>\nModuleNotFoundError: No module named 'websocket'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.553Z",
    "modified": "2026-02-21T00:48:55.586Z"
  },
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "28cecffd-38c8-4795-ba6f-77b1f6efdbe4",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC006-websocket generate supports new conversation reset",
    "description": "Test sending a new_conversation message on the WebSocket /generate endpoint and verify that the server responds with a conversation_reset message confirming the reset of conversation history.",
    "code": "import asyncio\nimport json\nimport websockets\n\nasync def test_websocket_generate_supports_new_conversation_reset():\n    uri = \"ws://127.0.0.1:8420/generate\"\n\n    async with websockets.connect(uri) as websocket:\n        # Send new_conversation message\n        await websocket.send(json.dumps({\"type\": \"new_conversation\"}))\n\n        # Receive response\n        response = await websocket.recv()\n        message = json.loads(response)\n\n        # Assert the response type is conversation_reset\n        assert isinstance(message, dict), \"Response is not a JSON object\"\n        assert message.get(\"type\") == \"conversation_reset\", f\"Expected type=conversation_reset, got: {message.get('type')}\"\n\nasyncio.run(test_websocket_generate_supports_new_conversation_reset())",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 3, in <module>\nModuleNotFoundError: No module named 'websockets'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.560Z",
    "modified": "2026-02-21T00:49:01.276Z"
  },
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "343c4c67-eb48-4e48-9c18-2a08a66120d7",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC007-websocket generate handles closed connection on new conversation reset",
    "description": "Test the behavior when sending a new_conversation message on the WebSocket /generate endpoint after the connection is closed, expecting the client send to fail or raise an error.",
    "code": "import websocket\nimport json\nimport pytest\nfrom testsprite_tests import proxy_connect\n\n\ndef test_websocket_generate_handles_closed_connection_on_new_conversation_reset():\n    ws_url = \"ws://localhost:8420/generate\"\n    ws = None\n    try:\n        ws = proxy_connect(ws_url)\n        ws.close()\n        with pytest.raises((websocket.WebSocketConnectionClosedException, websocket.WebSocketException, OSError)):\n            ws.send(json.dumps({\"type\": \"new_conversation\"}))\n    finally:\n        if ws and ws.sock and ws.sock.connected:\n            ws.close()\n\n\ntest_websocket_generate_handles_closed_connection_on_new_conversation_reset()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 1, in <module>\nModuleNotFoundError: No module named 'websocket'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.566Z",
    "modified": "2026-02-21T00:48:58.203Z"
  },
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "19f5dfa8-bc40-4b69-bc49-3039c29e5c2f",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC008-websocket generate builds messages based on mode and context",
    "description": "Test the WebSocket /generate endpoint with different modes (generate, rewrite, fix, translate) and optional context or screenshot, verifying that the server constructs appropriate user/system messages and streams the expected token messages.",
    "code": "import asyncio\nimport json\nimport websockets\nfrom testsprite_tests.proxy_connect import proxy_connect\n\nBASE_WS_ENDPOINT = \"ws://localhost:8420/generate\"\nTIMEOUT = 30\n\nasync def websocket_generate_builds_messages():\n    # Modes to test with optional context and screenshot variations\n    test_cases = [\n        {\"prompt\": \"Generate some text\", \"mode\": \"generate\", \"mode_type\": \"draft\", \"context\": \"Context for generation\"},\n        {\"prompt\": \"Rewrite this sentence\", \"mode\": \"rewrite\", \"mode_type\": \"chat\", \"context\": \"Previous turn text\"},\n        {\"prompt\": \"Fix this code snippet\", \"mode\": \"fix\", \"mode_type\": \"draft\", \"screenshot\": \"YmFzZTY0U2NyZWVu\"},  # base64 \"base64Screen\"\n        {\"prompt\": \"Translate to French\", \"mode\": \"translate\", \"mode_type\": \"chat\"}\n    ]\n\n    async def handle_case(case):\n        config = {\n            \"provider\": \"bedrock\",\n            \"model_id\": \"test-model\",\n            \"aws_profile\": \"default\",\n            \"aws_region\": \"us-west-2\"\n        }\n        payload = {\n            \"prompt\": case[\"prompt\"],\n            \"mode\": case[\"mode\"],\n            \"mode_type\": case.get(\"mode_type\", \"draft\"),\n            \"config\": config\n        }\n        if \"context\" in case:\n            payload[\"context\"] = case[\"context\"]\n        if \"screenshot\" in case:\n            payload[\"screenshot\"] = case[\"screenshot\"]\n\n        async with proxy_connect().connect(BASE_WS_ENDPOINT, ping_interval=None) as websocket:\n            await websocket.send(json.dumps(payload))\n            token_received = False\n            done_received = False\n            async for message in websocket:\n                data = json.loads(message)\n                msg_type = data.get(\"type\")\n                # Validate streaming token messages\n                if msg_type == \"token\":\n                    assert \"content\" in data and isinstance(data[\"content\"], str)\n                    token_received = True\n                elif msg_type == \"done\":\n                    assert \"content\" in data and isinstance(data[\"content\"], str)\n                    done_received = True\n                    break\n                elif msg_type == \"error\":\n                    # Fail test if error received for these valid modes\n                    assert False, f\"Error received in mode {case['mode']}: {data.get('content')}\"\n                else:\n                    # Can receive other types but not expected here, no fail\n                    pass\n            assert token_received, f\"No token message received for mode {case['mode']}\"\n            assert done_received, f\"No done message received for mode {case['mode']}\"\n\n    # Run all test cases sequentially with timeout\n    for case in test_cases:\n        await asyncio.wait_for(handle_case(case), timeout=TIMEOUT)\n\n# Run the test\nasyncio.get_event_loop().run_until_complete(websocket_generate_builds_messages())",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 3, in <module>\nModuleNotFoundError: No module named 'websockets'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.572Z",
    "modified": "2026-02-21T00:48:57.223Z"
  },
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "ae3ca857-9f53-459c-81c3-3b4f70916e8d",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC009-websocket generate returns error for invalid mode",
    "description": "Test sending a generation request with an invalid or unsupported mode on the WebSocket /generate endpoint and verify that the server responds with an error message indicating invalid mode.",
    "code": "import json\nimport websocket\n\ndef test_websocket_generate_returns_error_for_invalid_mode():\n    url = \"ws://127.0.0.1:8420/generate\"\n    invalid_mode_request = {\n        \"prompt\": \"Summarize this text quickly\",\n        \"context\": \"\",\n        \"mode\": \"summarize\",  # invalid/unsupported mode\n        \"mode_type\": \"draft\",\n        \"config\": {\n            \"provider\": \"bedrock\",\n            \"model_id\": \"dummy-model-id\",\n            \"aws_profile\": \"default\",\n            \"aws_region\": \"us-west-2\"\n        }\n    }\n\n    # Connect directly using websocket\n    ws = websocket.create_connection(url)\n\n    try:\n        ws.send(json.dumps(invalid_mode_request))\n\n        error_received = False\n        while True:\n            msg = ws.recv()\n            if not msg:\n                break\n            data = json.loads(msg)\n            # The server must respond with type=error and message about invalid mode\n            if data.get(\"type\") == \"error\":\n                error_received = True\n                error_message = data.get(\"content\", \"\")\n                assert \"invalid mode\" in error_message.lower() or \"unsupported mode\" in error_message.lower()\n                break\n        assert error_received, \"Expected error message for invalid mode not received\"\n    finally:\n        ws.close()\n\ntest_websocket_generate_returns_error_for_invalid_mode()\n",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 2, in <module>\nModuleNotFoundError: No module named 'websocket'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.577Z",
    "modified": "2026-02-21T00:49:07.872Z"
  },
  {
    "projectId": "c1d53d1b-0c47-4ded-81ac-493f65b33517",
    "testId": "ef46a721-c439-46e4-a355-95c6ae08a5bb",
    "userId": "649804a8-4001-7007-99df-569eb63fd915",
    "title": "TC010-websocket generate supports per request model configuration",
    "description": "Test the WebSocket /generate endpoint with per-request model configuration including provider, model_id, aws_profile, and aws_region, verifying that the server uses the specified model and streams tokens accordingly.",
    "code": "import websocket\nimport json\nimport pytest\nfrom testsprite_tests.proxy_connect import proxy_connect\n\n\ndef test_websocket_generate_per_request_model_configuration():\n    ws_url = \"ws://localhost:8420/generate\"\n    # Prepare the request with per-request model config\n    request_payload = {\n        \"prompt\": \"Hello, please generate text with specified model.\",\n        \"context\": \"Test context for per-request model config\",\n        \"mode\": \"generate\",\n        \"mode_type\": \"draft\",\n        \"config\": {\n            \"provider\": \"bedrock\",\n            \"model_id\": \"test-model-123\",\n            \"aws_profile\": \"default\",\n            \"aws_region\": \"us-west-2\"\n        }\n    }\n\n    messages = []\n\n    def on_message(ws, message):\n        msg = json.loads(message)\n        messages.append(msg)\n\n    def on_error(ws, error):\n        pytest.fail(f\"WebSocket error: {error}\")\n\n    def on_close(ws, close_status_code, close_msg):\n        pass  # No action needed on close\n\n    def on_open(ws):\n        ws.send(json.dumps(request_payload))\n\n    # Connect to websocket using proxy_connect helper for HTTP_PROXY tunnels if needed\n    ws = websocket.WebSocketApp(\n        ws_url,\n        on_open=on_open,\n        on_message=on_message,\n        on_error=on_error,\n        on_close=on_close,\n    )\n\n    # Run the websocket client in proxy_connect context to support proxy if configured\n    with proxy_connect(ws):\n        # Timeout and run forever until closed or done message received\n        # We'll close connection once done message is received to finish test early\n        def run_forever_with_done_check():\n            while True:\n                ws.run_forever(timeout=30, ping_interval=10, ping_timeout=5)\n                # Check for done message to exit\n                if any(msg.get(\"type\") == \"done\" for msg in messages):\n                    break\n                # If error message received, fail the test\n                if any(msg.get(\"type\") == \"error\" for msg in messages):\n                    error_msg = next(\n                        msg.get(\"content\") for msg in messages if msg.get(\"type\") == \"error\"\n                    )\n                    pytest.fail(f\"Server returned error: {error_msg}\")\n\n        run_forever_with_done_check()\n\n    # Assertions after websocket is closed\n    assert len(messages) > 0, \"No messages received from server\"\n    # Expect at least one token message and one done message\n    token_msgs = [m for m in messages if m.get(\"type\") == \"token\"]\n    done_msgs = [m for m in messages if m.get(\"type\") == \"done\"]\n    error_msgs = [m for m in messages if m.get(\"type\") == \"error\"]\n    cancelled_msgs = [m for m in messages if m.get(\"type\") == \"cancelled\"]\n\n    assert len(error_msgs) == 0, f\"Unexpected error messages: {error_msgs}\"\n    assert len(cancelled_msgs) == 0, f\"Unexpected cancelled messages: {cancelled_msgs}\"\n    assert len(token_msgs) > 0, \"No token messages received\"\n    assert len(done_msgs) == 1, \"Expected exactly one done message\"\n\n    # Validate done message contains expected keys and a finished generated text content\n    done_msg = done_msgs[0]\n    assert \"content\" in done_msg and isinstance(done_msg[\"content\"], str)\n    assert done_msg[\"content\"], \"Done message content is empty\"\n    # Validate streamed token contents concatenate to done content start (basic consistency)\n    token_content = \"\".join(m.get(\"content\", \"\") for m in token_msgs)\n    assert done_msg[\"content\"].startswith(token_content[: len(done_msg[\"content\"])])\n\n\ntest_websocket_generate_per_request_model_configuration()",
    "testStatus": "FAILED",
    "testError": "Traceback (most recent call last):\n  File \"/var/task/handler.py\", line 258, in run_with_retry\n    exec(code, exec_env)\n  File \"<string>\", line 1, in <module>\nModuleNotFoundError: No module named 'websocket'\n",
    "testType": "BACKEND",
    "createFrom": "mcp",
    "created": "2026-02-21T00:48:36.583Z",
    "modified": "2026-02-21T00:48:58.580Z"
  }
]
